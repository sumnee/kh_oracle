--@@@@ HAVING

--부서별 급여 평균이 3,000,000원(버림적용) 이상인  부서들에 대해서 부서명, 급여평균을 출력하세요.
SELECT DEPT_CODE, FLOOR(AVG(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING FLOOR(AVG(SALARY)) >= 3000000;
--GROUP BY로 산출한 결과에 대한 조건 HAVING / 순서도 WHERE랑 다르게 뒤에 적음

--@실습문제
--1. 부서별 인원이 5명보다 많은 부서와 인원수를 출력하세요.
SELECT DEPT_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING COUNT(*) >5;

--2. 부서별 내 직급별 인원수가 3명이상인 직급의 부서코드, 직급코드, 인원수를 출력하세요.
SELECT DEPT_CODE, JOB_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE
HAVING COUNT(*) >=3;

--3. 매니저가 관리하는 사원이 2명 이상인 매니저 아이디와 관리하는 사원수 출력
SELECT MANAGER_ID, COUNT(*) 사원수
FROM EMPLOYEE
GROUP BY MANAGER_ID
HAVING COUNT(*) >= 2 AND MANAGER_ID IS NOT NULL
ORDER BY 1;

--@@@@ ROLLUP // CUBE
SELECT JOB_CODE, COUNT(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(JOB_CODE)
ORDER BY 1;

SELECT JOB_CODE, COUNT(SALARY)
FROM EMPLOYEE
GROUP BY CUBE(JOB_CODE)
ORDER BY 1;
--상기 두가지 코드처럼 그룹 기준이 하나인 경우에 차이가 없다


--부서내 직급별 급여 합계
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(DEPT_CODE, JOB_CODE)
ORDER BY 1;
--부서별 합

SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY CUBE(DEPT_CODE, JOB_CODE)
ORDER BY 1;
--부서별 직급별 합

--@@@@ 집합연산자 RESULTSET
--교집합 INTERSECT 
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE DEPT_CODE = 'D5'
INTERSECT
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE SALARY >=2400000;

--합집합 UNION(중복 제거) / UNION ALL(중복 허용)
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE DEPT_CODE = 'D5'
UNION 
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE SALARY >=2400000;
--UNION 사용의 조건
--1.SELECT문의 컬럼 개수가 반드시 같아야
--2.컬럼의 데이터 타입이 반드시 같거나 변환 가능해야

--차집합 MINUS 
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE DEPT_CODE = 'D5'
MINUS 
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE SALARY >=2400000;

--@@@ JOIN
--여러테이블의 레코드를 조합하여 하나의 열로 표현
--두개 이상의 테이블에서 연관성 있는 데이터들을 컬럼기준으로 분류하여 새로운 가상 테이블에 출력
--즉, 서로 다른 테이블에서 각각의 공통값을 이용함으로서 필드를 조합함

--1. 사원명과, 부서명을 출력하세요.
--   부서코드가 D5이면 총무부, D6이면 기획부, D9이면 영업부로 처리하시오.
--   부서코드가 D5, D6, D9 인 직원의 정보만 조회
SELECT EMP_NAME, DEPT_CODE
FROM EMPLOYEE
WHERE DEPT_CODE IN ('D5','D6','D9');
SELECT * FROM DEPARTMENT;

SELECT EMP_NAME, DEPT_CODE FROM EMPLOYEE;
SELECT DEPT_ID, DEPT_TITLE FROM DEPARTMENT;

--@@@ JOIN문1
--ANSI 표준 구문
SELECT EMP_NAME, DEPT_TITLE FROM EMPLOYEE
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;

--오라클 전용 구문
SELECT EMP_NAME, DEPT_TITLE FROM EMPLOYEE, DEPARTMENT 
WHERE DEPT_CODE = DEPT_ID;

--EQUI-JOIN : ON 뒤에 공통조건 기록, 일반적 사용
--NON-EQUI-JOIN : BETWEEN AND, IS NULL, IN 등으로 사용

--@실습문제

--1. 부서명과 지역명을 출력하세요. DEPARTMENT, LOCATION 테이블 이용.
SELECT DEPT_TITLE, LOCAL_NAME FROM DEPARTMENT
JOIN LOCATION ON LOCATION_ID = LOCAL_CODE;

--2. 사원명과 직급명을 출력하세요. EMPLOYEE, JOB 테이블 이용
--ON 이후 칼럼명이 같으면 오류, 출처 테이블을 표시해주어야함!
SELECT EMP_NAME, JOB_NAME FROM EMPLOYEE
JOIN JOB ON EMPLOYEE.JOB_CODE = JOB.JOB_CODE;
--테이블 출처 직접 표시하여 해결
SELECT EMP_NAME, JOB_NAME FROM EMPLOYEE E
JOIN JOB J ON E.JOB_CODE = J.JOB_CODE;
--테이블 별칭 사용해 오류 해결
SELECT EMP_NAME, JOB_NAME FROM EMPLOYEE
JOIN JOB USING(JOB_CODE);
--USING 사용해 오류 해결

-- 3. 지역명과 국가명을 출력하세요. LOCATION, NATION 테이블 이용
SELECT LOCAL_NAME, NATIONAL_NAME FROM LOCATION
JOIN NATIONAL USING(NATIONAL_CODE);

--@@@ JOIN문2
--INNER JOIN : 일반적 사용, 교집합
--OUTER JOIN : 합집합, 모두 출력
--- > 1. LEFT  (OUTER) JOIN : LEFT기준 모두 출력
--- > 2. RIGHT (OUTER) JOIN : RIGHT기준 모두 출력
--- > 3. FULL  (OUTER) JOIN : 모두 출력
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE LEFT JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;
--LEFT인 DEPT_CODE 기준 모두 출력

--오라클 전용 구문
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT WHERE DEPT_CODE = DEPT_ID(+);
--DEPT_ID 기준 모두 출력 //DEPT_CODE(+) = DEPT_ID 하면 DEPT_CODE기준임!
--FULL JOIN은 ANSI 표준 구문만 가넝~

--EX.OUTER JOIN
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE LEFT JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;

SELECT EMP_NAME, DEPT_TITLE
FROM DEPARTMENT RIGHT JOIN EMPLOYEE ON DEPT_ID = DEPT_CODE;

--@@@ JOIN문3
--1. CROSS JOIN
--2. SELF JOIN
--3. 다중 JOIN : 여러개의 조인문을 한번에 사용 / 순서가 중요
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE 
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
JOIN LOCATION ON LOCATION_ID = LOCAL_CODE;

--@실습문제
-- 직급이 대리이면서, ASIA 지역에 근무하는 직원 조회
-- 사번, 이름 ,직급명, 부서명, 근무지역명, 급여를 조회하시오
SELECT EMP_ID,EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, SALARY
FROM EMPLOYEE 
JOIN JOB USING(JOB_CODE)
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
JOIN LOCATION ON LOCATION_ID = LOCAL_CODE
WHERE JOB_NAME = '대리' AND LOCAL_NAME LIKE 'ASIA%';

--@ 조인 실습문제
--1. 2022년 12월 25일이 무슨 요일인지 조회하시오.
SELECT TO_CHAR(TO_DATE(20221225), 'DAY') 크리스마스 FROM DUAL;

--2. 주민번호가 1970년대 생이면서 성별이 여자이고, 성이 전씨인 직원들의 사원명, 주민번호, 부서명, 직급명을 조회하시오.
SELECT EMP_NAME,EMP_NO, DEPT_TITLE, JOB_NAME
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE)
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
WHERE (SUBSTR(EMP_NO,1,2)) BETWEEN 70 AND 79 AND SUBSTR(EMP_NO,8,1)='2'
AND EMP_NAME LIKE '전%';

--3. 이름에 '형'자가 들어가는 직원들의 사번, 사원명, 부서명을 조회하시오.
SELECT EMP_ID, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
WHERE EMP_NAME LIKE '%형%';

--4. 해외영업부에 근무하는 사원명, 직급명, 부서코드, 부서명을 조회하시오.
SELECT EMP_NAME, JOB_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE)
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
WHERE DEPT_TITLE LIKE '해외영업%';

--5. 보너스포인트를 받는 직원들의 사원명, 보너스포인트, 부서명, 근무지역명을 조회하시오.
SELECT EMP_NAME, BONUS, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
JOIN LOCATION ON LOCATION_ID = LOCAL_CODE
WHERE BONUS IS NOT NULL;

--6. 부서코드가 D2인 직원들의 사원명, 직급명, 부서명, 근무지역명을 조회하시오.
SELECT EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE)
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
JOIN LOCATION ON LOCATION_ID = LOCAL_CODE
WHERE DEPT_CODE = 'D2';

--7. 급여등급테이블의 최대급여(MAX_SAL)보다 많이 받는 직원들의 사원명, 직급명, 급여, 연봉을 조회하시오.
SELECT EMP_NAME, JOB_NAME, SALARY, SALARY*12 연봉
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE)
JOIN SAL_GRADE USING(SAL_LEVER)
WHERE SALARY > MAX_SAL; ???

--8. 한국(KO)과 일본(JP)에 근무하는 직원들의 사원명, 부서명, 지역명, 국가명을 조회하시오.
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME, NATIONAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
JOIN LOCATION ON LOCATION_ID = LOCAL_CODE
JOIN NATIONAL USING (NATIONAL_CODE)
WHERE NATIONAL_NAME IN ('한국','일본');

--9. 보너스포인트가 없는 직원들 중에서 직급이 차장과 사원인 직원들의 사원명, 직급명, 급여를 조회하시오.
SELECT EMP_NAME, JOB_NAME, SALARY
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE)
WHERE JOB_NAME IN ('차장', '사원') AND BONUS IS NULL;

--10. 재직중인 직원과 퇴사한 직원의 수를 조회하시오.
SELECT DECODE(ENT_YN, 'Y','퇴직', 'N', '재직') AS 근속여부, COUNT(*) AS 직원수
FROM EMPLOYEE
GROUP BY DECODE(ENT_YN, 'Y','퇴직', 'N', '재직');









